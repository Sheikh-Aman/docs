---
title: "Using Aion's Pre-compiled Smart Contracts"
excerpt: "Aion Pre-compiled Smart Contracts consist of the Bridge pre-compiled contract and the Token Release Schedule(TRS) Pre-Compiled Contract! the coding could be found below."
---
[block:callout]
{
  "type": "warning",
  "title": "Bounty",
  "body": "This page is under development - please **[read the rules](https://aion.network/bounty/content-creation-bounty/)** on how to contribute. Make sure you've familiarized yourself with the **[Tone and Voice Guidelines](https://docs.aion.network/page/voice-guidelines)** for content contributions. Keywords you can focus on for this page **smart contract tutorial**, **smart contracts**"
}
[/block]

[block:api-header]
{
  "title": "Bridge Pre-Compiled Contract"
}
[/block]
https://github.com/aionnetwork/aion/tree/master/modPrecompiled/src/org/aion/precompiled/contracts/ATB
[block:code]
{
  "codes": [
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport static org.aion.precompiled.contracts.ATB.BridgeController.ProcessedResults.processError;\nimport static org.aion.precompiled.contracts.ATB.BridgeController.ProcessedResults.processSuccess;\nimport static org.aion.precompiled.contracts.ATB.BridgeUtilities.computeBundleHash;\n\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.annotation.Nonnull;\n\nimport org.aion.base.type.Address;\nimport org.aion.base.util.ByteUtil;\nimport org.aion.crypto.ISignature;\nimport org.aion.crypto.SignatureFac;\nimport org.aion.mcf.vm.types.Log;\nimport org.aion.precompiled.PrecompiledUtilities;\nimport org.aion.vm.ExecutionHelper;\nimport org.aion.vm.ExecutionResult;\n\n/**\n * Contains the functional components of the Aion Token Bridge, this class is removed\n * from concerns regarding communicate with outside world (external) and communicating\n * with the database.\n */\npublic class BridgeController {\n\n    private final BridgeStorageConnector connector;\n    private final ExecutionHelper result;\n    private final Address contractAddress;\n    private final Address ownerAddress;\n    private Transferable transferable;\n\n    public BridgeController(@Nonnull final BridgeStorageConnector storageConnector,\n                            @Nonnull final ExecutionHelper helper,\n                            @Nonnull final Address contractAddress,\n                            @Nonnull final Address ownerAddress) {\n        this.connector = storageConnector;\n        this.result = helper;\n        this.contractAddress = contractAddress;\n        this.ownerAddress = ownerAddress;\n    }\n\n    public void setTransferable(Transferable transferable) {\n        this.transferable = transferable;\n    }\n\n    /**\n     * Loads in the stored state from the underlying repository\n     */\n    public void initialize() {\n        if (this.connector.getInitialized())\n            return;\n        // otherwise initialize\n        this.connector.setOwner(ownerAddress.toBytes());\n        this.connector.setInitialized(true);\n    }\n\n    // owner\n\n    // guards/modifiers\n\n    /**\n     * Checks whether the given address is the owner of the contract or not.\n     *\n     * @param address to be checked for ownership\n     * @return {@code true} if address is the owner {@code false} otherwise\n     * @implNote assumes the address is non-null and properly formatted\n     */\n    private boolean isOwner(@Nonnull final byte[] address) {\n        byte[] owner = this.connector.getOwner();\n        return owner != null && Arrays.equals(owner, address);\n    }\n\n    /**\n     * Checks whether the given address is the intended newOwner of the contract\n     *\n     * @param address to be checked for new ownership\n     * @return {@code} true if the address is the intended new owner {@code false} otherwise\n     */\n    private boolean isNewOwner(@Nonnull final byte[] address) {\n        byte[] newOwner = this.connector.getNewOwner();\n        return newOwner != null && Arrays.equals(newOwner, address);\n    }\n\n    // logic\n    public ErrCode setNewOwner(@Nonnull final byte[] caller,\n                               @Nonnull final byte[] newOwner) {\n        if (!isOwner(caller))\n            return ErrCode.NOT_OWNER;\n        this.connector.setNewOwner(newOwner);\n        return ErrCode.NO_ERROR;\n    }\n\n    public ErrCode acceptOwnership(@Nonnull final byte[] caller) {\n        if (!isNewOwner(caller))\n            return ErrCode.NOT_NEW_OWNER;\n        this.connector.setOwner(caller);\n        this.connector.setNewOwner(ByteUtil.EMPTY_WORD);\n\n        emitChangedOwner(caller);\n        return ErrCode.NO_ERROR;\n    }\n\n    // end owner\n\n    // relayer\n\n    private boolean isRelayer(@Nonnull final byte[] caller) {\n        byte[] relayer = this.connector.getRelayer();\n        return relayer != null && Arrays.equals(caller, this.connector.getRelayer());\n    }\n\n    public ErrCode setRelayer(@Nonnull final byte[] caller,\n                              @Nonnull final byte[] newOwner) {\n        if (!isOwner(caller))\n            return ErrCode.NOT_OWNER;\n        this.connector.setRelayer(newOwner);\n        return ErrCode.NO_ERROR;\n    }\n\n    // end relayer\n\n    // ring\n\n    private static int thresholdRatio(final int in) {\n        return Math.max((in * 2) / 3, 1);\n    }\n\n    private boolean isRingLocked() {\n        return this.connector.getRingLocked();\n    }\n\n    private boolean isRingMember(@Nonnull final byte[] address) {\n        return this.connector.getActiveMember(address);\n    }\n\n    public ErrCode ringInitialize(@Nonnull final byte[] caller,\n                                  @Nonnull final byte[][] members) {\n        if (!isOwner(caller))\n            return ErrCode.NOT_OWNER;\n\n        if (isRingLocked())\n            return ErrCode.RING_LOCKED;\n\n        int thresh = thresholdRatio(members.length);\n\n        this.connector.setMemberCount(members.length);\n        this.connector.setMinThresh(thresh);\n\n        for (byte[] m : members) {\n            this.connector.setActiveMember(m, true);\n        }\n        this.connector.setRingLocked(true);\n        return ErrCode.NO_ERROR;\n    }\n\n    public ErrCode ringAddMember(@Nonnull final byte[] caller,\n                                 @Nonnull final byte[] address) {\n        if (!isOwner(caller))\n            return ErrCode.NOT_OWNER;\n\n        if (!isRingLocked())\n            return ErrCode.RING_NOT_LOCKED;\n\n        if (isRingMember(address))\n            return ErrCode.RING_MEMBER_EXISTS;\n\n        int memberCount = this.connector.getMemberCount() + 1;\n        int thresh = thresholdRatio(memberCount);\n\n        this.connector.setActiveMember(address, true);\n        this.connector.setMemberCount(memberCount);\n        this.connector.setMinThresh(thresh);\n\n        emitAddMember(address);\n        return ErrCode.NO_ERROR;\n    }\n\n    public ErrCode ringRemoveMember(@Nonnull final byte[] caller,\n                                    @Nonnull final byte[] address) {\n        if (!isOwner(caller))\n            return ErrCode.NOT_OWNER;\n\n        if (!isRingLocked())\n            return ErrCode.RING_NOT_LOCKED;\n\n        if (!isRingMember(address))\n            return ErrCode.RING_MEMBER_NOT_EXISTS;\n\n        int memberCount = this.connector.getMemberCount() - 1;\n        int thresh = thresholdRatio(memberCount);\n\n        this.connector.setActiveMember(address, false);\n        this.connector.setMemberCount(memberCount);\n        this.connector.setMinThresh(thresh);\n\n        emitRemoveMember(address);\n        return ErrCode.NO_ERROR;\n    }\n\n    // end ring\n\n    // bridge\n\n    private boolean isWithinSignatureBounds(int signatureLength) {\n        int thresh = this.connector.getMinThresh();\n        return signatureLength >= thresh && signatureLength <= this.connector.getMemberCount();\n    }\n\n    private boolean bundleProcessed(@Nonnull final byte[] hash) {\n        return !Arrays.equals(this.connector.getBundle(hash), ByteUtil.EMPTY_WORD);\n    }\n\n    /**\n     * Assume bundleHash is not from external source, but rather\n     * calculated on our side (on the I/O layer), when {@link BridgeTransfer} list\n     * was being created.\n     *\n     * @param caller,          address of the calling account. Used to check whether\n     *                         the address calling is the relay or not.\n     * @param sourceBlockHash, hash of a block on the source blockchain, each\n     *                         block may contain 1 to N bundles. Used as part\n     *                         of the bundleHash to tie a bundle to a block.\n     * @param transfers,       {@link BridgeTransfer}\n     * @param signatures,      a list of signatures from signatories that have signed\n     *                         the bundles.\n     * @return {@code ErrCode} indicating whether operation was successful\n     * @implNote assume the inputs are properly formatted\n     * @implNote will check whether any bundles are {@code 0} value transfers.\n     * In such a case, it indicates that the bridge has faulted, so we should\n     * immediately fail all transfers.\n     * @implNote {@link BridgeDeserializer} implicitly places a max size for each\n     * list to 512.\n     */\n    public ProcessedResults processBundles(@Nonnull final byte[] caller,\n                                           @Nonnull final byte[] transactionHash,\n                                           @Nonnull final byte[] sourceBlockHash,\n                                           @Nonnull final BridgeTransfer[] transfers,\n                                           @Nonnull final byte[][] signatures) {\n        if (!isRingLocked())\n            return processError(ErrCode.RING_NOT_LOCKED);\n\n        if (!isRelayer(caller))\n            return processError(ErrCode.NOT_RELAYER);\n\n        if (!isWithinSignatureBounds(signatures.length))\n            return processError(ErrCode.INVALID_SIGNATURE_BOUNDS);\n\n        /*\n         * Computes a unique identifier of the transfer hash for each sourceBlockHash,\n         * uniqueness relies on the fact that each\n         */\n\n        // verify bundleHash\n        byte[] hash = computeBundleHash(sourceBlockHash, transfers);\n\n        // ATB 4-1, a transaction submitting a bundle that has already been\n        // submitted should not trigger a failure. Instead we should emit\n        // an event indicating the transactionHash that the bundle was\n        // previously successfully broadcast in.\n        if (bundleProcessed(hash)) {\n            // ATB 6-1, fixed bug: emit stored transactionHash instead of input transaction Hash\n            emitSuccessfulTransactionHash(this.connector.getBundle(hash));\n            return processSuccess(Collections.emptyList());\n        }\n\n        int signed = 0;\n        for (byte[] sigBytes : signatures) {\n            ISignature sig = SignatureFac.fromBytes(sigBytes);\n            if (SignatureFac.verify(hash, sig) && this.connector.getActiveMember(sig.getAddress())) {\n                signed++;\n            }\n        }\n\n        int minThresh = this.connector.getMinThresh();\n        if (signed < minThresh)\n            return processError(ErrCode.NOT_ENOUGH_SIGNATURES);\n\n        // otherwise, we're clear to proceed with transfers\n        List<ExecutionResult> results = new ArrayList<>();\n        for (BridgeTransfer b : transfers) {\n\n            if (b.getTransferValue().compareTo(BigInteger.ZERO) == 0)\n                return processError(ErrCode.INVALID_TRANSFER);\n\n            /*\n             * Tricky here, we distinguish between two types of failures here:\n             *\n             * 1) A balance failure indicates we've failed to load the bridge with\n             * enough currency to execute, this means the whole transaction should\n             * fail and cause the bridge to exit\n             *\n             * 2) Any other failure indicates that either the contract had code,\n             * which means the contract is now considered null.\n             *\n             * For how this is documented, check the {@code Transferable}\n             * interface documentation.\n             */\n            ExecutionResult result;\n            if ((result = transferable.transfer(b.getRecipient(), b.getTransferValue())).getResultCode()\n                    == ExecutionResult.ResultCode.FAILURE)\n                // no need to return list of transactions, since they're all being dropped\n                return processError(ErrCode.INVALID_TRANSFER);\n\n            // otherwise if transfer was successful\n            if (result.getResultCode() == ExecutionResult.ResultCode.SUCCESS)\n                if (!emitDistributed(b.getSourceTransactionHash(), b.getRecipient(), b.getTransferValue()))\n                    return processError(ErrCode.INVALID_TRANSFER);\n            results.add(result);\n        }\n        this.connector.setBundle(hash, transactionHash);\n        emitProcessedBundle(sourceBlockHash, hash);\n        return processSuccess(results);\n    }\n\n    private void addLog(List<byte[]> topics) {\n        this.result.addLog(new Log(this.contractAddress, topics, null));\n    }\n\n    private void emitAddMember(@Nonnull final byte[] address) {\n        List<byte[]> topics = Arrays.asList(BridgeEventSig.ADD_MEMBER.getHashed(), address);\n        addLog(topics);\n    }\n\n    private void emitRemoveMember(@Nonnull final byte[] address) {\n        List<byte[]> topics = Arrays.asList(BridgeEventSig.REMOVE_MEMBER.getHashed(), address);\n        addLog(topics);\n    }\n\n    private void emitChangedOwner(@Nonnull final byte[] ownerAddress) {\n        List<byte[]> topics = Arrays.asList(BridgeEventSig.CHANGE_OWNER.getHashed(), ownerAddress);\n        addLog(topics);\n    }\n\n    // events\n    private boolean emitDistributed(@Nonnull final byte[] sourceTransactionHash,\n                                 @Nonnull final byte[] recipient,\n                                 @Nonnull final BigInteger value) {\n        byte[] paddedValue = PrecompiledUtilities.pad(value.toByteArray(), 32);\n        if (paddedValue == null)\n            return false;\n\n        List<byte[]> topics = Arrays.asList(\n                BridgeEventSig.DISTRIBUTED.getHashed(),\n                sourceTransactionHash,\n                recipient,\n                paddedValue);\n        addLog(topics);\n        return true;\n    }\n\n    private void emitProcessedBundle(@Nonnull final byte[] sourceBlockHash,\n                                     @Nonnull final byte[] bundleHash) {\n        List<byte[]> topics = Arrays.asList(\n                BridgeEventSig.PROCESSED_BUNDLE.getHashed(),\n                sourceBlockHash,\n                bundleHash);\n        addLog(topics);\n    }\n\n    private void emitSuccessfulTransactionHash(@Nonnull final byte[] aionTransactionHash) {\n        List<byte[]> topics = Arrays.asList(\n                BridgeEventSig.SUCCESSFUL_TXHASH.getHashed(),\n                aionTransactionHash);\n        addLog(topics);\n    }\n\n    static class ProcessedResults {\n        final ErrCode controllerResult;\n        final List<ExecutionResult> internalResults;\n\n        private ProcessedResults(ErrCode code, List<ExecutionResult> internalResults) {\n            this.controllerResult = code;\n            this.internalResults = internalResults;\n        }\n\n        static ProcessedResults processError(ErrCode code) {\n            return new ProcessedResults(code, null);\n        }\n\n        static ProcessedResults processSuccess(List<ExecutionResult> results) {\n            return new ProcessedResults(ErrCode.NO_ERROR, results);\n        }\n    }\n}",
      "language": "javascript",
      "name": "BridgeController.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport org.aion.base.util.ByteUtil;\n\nimport javax.annotation.Nonnull;\nimport java.math.BigInteger;\n\npublic class BridgeDeserializer {\n\n    private static final int ERR_INT = -1;\n\n    private static final int CALL_OFFSET = 4;\n    private static final int DWORD_SIZE = 32;\n    private static final int ADDR_SIZE = 32;\n\n    /**\n     * Size of a \"meta\" element for defining lists. There are two types, the\n     * first is an offset pointer than points to the location of the list.\n     *\n     * The second is a length, that depicts the length of the list. In compliance\n     * with Solidity Encoding in the FVM, both are 16 bytes.\n     *\n     * We note here that despite being 16 bytes, we only use enough bytes such that\n     * the range stays within a positive integer (31 bits).\n     */\n    private static final int LIST_META = 16;\n\n    private static final int LIST_SIZE_MAX = 512;\n\n    private static final BigInteger INT_MAX_VAL = BigInteger.valueOf(Integer.MAX_VALUE);\n\n    static byte[] parseDwordFromCall(@Nonnull final byte[] call) {\n        if (call.length < (DWORD_SIZE + CALL_OFFSET))\n            return null;\n        final byte[] dword = new byte[DWORD_SIZE];\n        System.arraycopy(call, CALL_OFFSET, dword, 0, ADDR_SIZE);\n        return dword;\n    }\n\n    /**\n     * Parses a call with one owner address, externally this is known as\n     * {@code changeOwner}\n     *\n     * @implNote assume that input contains function signature\n     *\n     * @param call input call with function signature\n     * @return {@code address} of new owner, {@code null} if anything is invalid\n     */\n    static byte[] parseAddressFromCall(@Nonnull final byte[] call) {\n        byte[] address = parseDwordFromCall(call);\n        return isInvalidAddress(address) ? null : address;\n    }\n\n    /**\n     * Parses a list of addresses from input, currently only used by\n     * ring initialization. This method enforces some checks on the class\n     * of addresses before parsed, in that they <b>must</b> be user addresses\n     * (start with {@code 0xa0}).\n     *\n     * The implication being that you may not set a non-user, address to be\n     * a ring member.\n     *\n     * @param call input data\n     * @return {@code 2d array} containing list of addresses. {@code null} otherwise.\n     */\n    static byte[][] parseAddressList(@Nonnull final byte[] call) {\n        // check minimum length\n        if (call.length < CALL_OFFSET + (LIST_META *2))\n            return null;\n\n        final byte[][] addressList = parseList(call, CALL_OFFSET, 32);\n\n        if (addressList == null)\n            return null;\n\n        // do a final check for address validity, if you're not sure what is\n        // considered a valid address in this contract please see the function\n        // below, note the implications with regards to the bridge design\n        for (final byte[] l : addressList) {\n            if (isInvalidAddress(l))\n                return null;\n        }\n        return addressList;\n    }\n\n    /**\n     * @implNote perhaps a length check is wrongly added here too, we do not want to\n     * check later as other deserialization would be a waste.\n     *\n     * @param call input data\n     * @return {@code BundleRequestCall} containing deserialized data\n     * {@code null} if anything regarding deserialization is wrong\n     */\n    static BundleRequestCall parseBundleRequest(@Nonnull final byte[] call) {\n\n        // account for 5 lists: sourceTransactionList, addressList, valueList, signatureChunks(1,2,3)\n        if (call.length < CALL_OFFSET + DWORD_SIZE + (LIST_META * 2) * 5)\n            return null;\n\n        final byte[] blockHash = parseDwordFromCall(call);\n\n        if (blockHash == null)\n            return null;\n\n        final byte[][] sourceTransactionList = parseList(call, CALL_OFFSET + DWORD_SIZE, 32);\n        if (sourceTransactionList == null)\n            return null;\n\n        final byte[][] addressList = parseList(call, CALL_OFFSET + DWORD_SIZE + LIST_META, 32);\n        if (addressList == null)\n            return null;\n\n        final byte[][] uintList = parseList(call, CALL_OFFSET + DWORD_SIZE + (LIST_META * 2), 16);\n        if (uintList == null)\n            return null;\n\n        // len(addressList) == len(uintList) == len(sourceTransactionList)\n        if (addressList.length != uintList.length || addressList.length != sourceTransactionList.length)\n            return null;\n\n        final byte[][] signatureChunk1 = parseList(call, CALL_OFFSET + (LIST_META * 3) + DWORD_SIZE, 32);\n        if (signatureChunk1 == null)\n            return null;\n\n        final byte[][] signatureChunk2 = parseList(call, CALL_OFFSET + (LIST_META * 4) + DWORD_SIZE, 32);\n        if (signatureChunk2 == null)\n            return null;\n\n        final byte[][] signatureChunk3 = parseList(call, CALL_OFFSET + (LIST_META * 5) + DWORD_SIZE, 32);\n        if (signatureChunk3 == null)\n            return null;\n\n        // len(signatureChunk1) == len(signatureChunk2) == len(signatureChunk3)\n        if (signatureChunk1.length != signatureChunk2.length || signatureChunk1.length != signatureChunk3.length)\n            return null;\n\n        final byte[][] mergedSignatureList = new byte[signatureChunk2.length][];\n        for (int i = 0; i < signatureChunk2.length; i++) {\n            mergedSignatureList[i] = ByteUtil.merge(signatureChunk1[i], signatureChunk2[i], signatureChunk3[i]);\n        }\n\n        // assemble bundle\n\n        BridgeTransfer[] bundles = new BridgeTransfer[uintList.length];\n        for (int i = 0; i < uintList.length; i++) {\n            BridgeTransfer transfer = BridgeTransfer.getInstance(\n                new BigInteger(1, uintList[i]),\n                addressList[i],\n                sourceTransactionList[i]);\n\n            if (transfer == null)\n                return null;\n\n            bundles[i] = transfer;\n        }\n\n        return new BundleRequestCall(blockHash, bundles, mergedSignatureList);\n    }\n\n    /**\n     * Parses a list given an offset, where the offset indicates the index that\n     * contains the list metadata (offset) value.\n     *\n     * Recall that list is encoded in the following pattern:\n     * [pointer to list metadata] ... [list metadata (length)][element][...]\n     *\n     * @implNote we assume that the maximum size of each input will be limited to\n     * {@code Integer.MAX_VALUE}\n     *\n     * @param call input call (with function signature)\n     * @param offset the offset in the call at which to start\n     * @param elementLength the length of each element in the array\n     * @return {@code array} of byte arrays, or {@code null} if list is improperly formatted\n     */\n    private static byte[][] parseList(@Nonnull final byte[] call,\n                                      final int offset,\n                                      final int elementLength) {\n        final int callLength = call.length;\n\n        // check minimum length\n        if (callLength < offset + (LIST_META * 2))\n            return null;\n\n        /*\n         * Correct case S#1, found that we previously incremented the listOffset before\n         * checking for ERR_INT, would have led to a situation where this check\n         * (whether the first listOffset was invalid or not) would not trigger.\n         *\n         * Correct by checking before incrementing with CALL_OFFSET.\n         */\n        int listOffset = parseMeta(call, offset);\n        if (listOffset == ERR_INT)\n            return null;\n        listOffset = listOffset + CALL_OFFSET;\n\n        /*\n         * parseMeta() performs checks on listOffset.\n         */\n        final int listLength = parseMeta(call, listOffset);\n        if (listLength == ERR_INT)\n            return null;\n\n        /*\n         * Covers case Y#2, if attacker tries to construct and overflow to OOM output array,\n         * it will be caught here.\n         */\n        int consumedLength;\n        try {\n            consumedLength = Math.multiplyExact(listLength, elementLength);\n        } catch (ArithmeticException e) {\n            return null;\n        }\n\n        /*\n         * Cover case S#4, assign an upper bound to the size of array we create.\n         * Under current gas estimations, our token takes approximately 30k-50k gas for a\n         * transfer.\n         *\n         * 30_000 * 512 = 15_360_000, which is above the current Ethereum block limit.\n         * Otherwise, if the limit does increase, we can simply cut bundles at this length.\n         */\n        if (listLength > LIST_SIZE_MAX)\n            return null;\n\n        /*\n         * Recall that we confirmed listOffset <= call.length. To check that offset, we then\n         * further consumed the offset position.\n         */\n        if (consumedLength > (call.length - listOffset - LIST_META))\n            return null;\n\n        final byte[][] output = new byte[listLength][];\n\n        // ensuring the range is within integer positive values\n        int start = listOffset + LIST_META;\n        if (start < 0) { // overflow\n            return null;\n        }\n        int end = start + consumedLength;\n        if (end < 0) { // overflow\n            return null;\n        }\n\n        int counter = 0;\n        for (int i = start; i < end; i += elementLength) {\n            byte[] element = new byte[elementLength];\n            System.arraycopy(call, i, element, 0, elementLength);\n            output[counter] = element;\n            counter++;\n        }\n        return output;\n    }\n\n\n    private static int parseMeta(@Nonnull final byte[] call,\n                                 final int offset) {\n\n        // check for out of bounds exceptions, each one of these is important to check since integer\n        // overflow can be taken advantage of to pass this block if one of these is omitted.\n        if ((offset < 0) || (offset > call.length) || (offset + LIST_META > call.length))\n            return ERR_INT;\n\n        // more minimum length checks\n        final byte[] pt = new byte[LIST_META];\n        System.arraycopy(call, offset, pt, 0, LIST_META);\n\n        // check that destination is parse-able\n        final BigInteger bigInt = new BigInteger(1, pt);\n        if (bigInt.compareTo(INT_MAX_VAL) > 0)\n            return ERR_INT;\n\n        try {\n            return bigInt.intValueExact();\n        } catch (ArithmeticException e) {\n            /*\n             * Catch case S#3, handles the case where someone could overload\n             * the biginteger, and try to create a value larger than INT_MAX,\n             * in this case we should consider the meta decode a failure and\n             * return -1;\n             */\n            return ERR_INT;\n        }\n    }\n\n    private static final byte ADDRESS_HEADER = ByteUtil.hexStringToBytes(\"0xa0\")[0];\n\n    /**\n     * @implNote something interesting here: enforcing 0xa0 in our address checks\n     * prevents people from sending transactions to random addresses (that do not contain\n     * the header), not sure if this will cause some unintended consequences.\n     *\n     * @param address the address checked for validity\n     * @return {@code true} if address invalid, {@code false} otherwise\n     */\n    private static boolean isInvalidAddress(byte[] address) {\n        return address == null || address.length != 32 || address[0] != ADDRESS_HEADER;\n    }\n}",
      "language": "javascript",
      "name": " \tBridgeDeserializer.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport javax.annotation.Nonnull;\n\nimport static org.aion.precompiled.contracts.ATB.BridgeUtilities.*;\n\nenum BridgeEventSig {\n    CHANGE_OWNER        (\"ChangedOwner(address)\"),\n    ADD_MEMBER          (\"AddMember(address)\"),\n    REMOVE_MEMBER       (\"RemoveMember(address)\"),\n    PROCESSED_BUNDLE    (\"ProcessedBundle(bytes32,bytes32)\"),\n    DISTRIBUTED         (\"Distributed(bytes32,address,uint128)\"),\n    SUCCESSFUL_TXHASH   (\"SuccessfulTxHash(bytes32)\");\n\n    private final byte[] hashed;\n    BridgeEventSig(@Nonnull final String eventSignature) {\n        this.hashed = toEventSignature(eventSignature);\n    }\n\n    public byte[] getHashed() {\n        return this.hashed;\n    }\n}",
      "language": "javascript",
      "name": " \tBridgeEventSig.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport org.aion.base.util.ByteArrayWrapper;\n\nimport javax.annotation.Nonnull;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.aion.precompiled.contracts.ATB.BridgeUtilities.toSignature;\n\nenum BridgeFuncSig {\n    SIG_CHANGE_OWNER        (\"changeOwner(address)\"),\n    SIG_ACCEPT_OWNERSHIP    (\"acceptOwnership()\"),\n    SIG_RING_INITIALIZE     (\"initializeRing(address[])\"),\n    SIG_RING_ADD_MEMBER     (\"addRingMember(address)\"),\n    SIG_RING_REMOVE_MEMBER  (\"removeRingMember(address)\"),\n    SIG_SET_RELAYER         (\"setRelayer(address)\"),\n    SIG_SUBMIT_BUNDLE       (\"submitBundle(bytes32,bytes32[],address[],uint128[],bytes32[],bytes32[],bytes32[])\"),\n    PURE_OWNER              (\"owner()\"),\n    PURE_NEW_OWNER          (\"newOwner()\"),\n    PURE_ACTION_MAP         (\"actionMap(bytes32)\"),\n    PURE_RING_MAP           (\"ringMap(address)\"),\n    PURE_RING_LOCKED        (\"ringLocked()\"),\n    PURE_MIN_THRESH         (\"minThresh()\"),\n    PURE_MEMBER_COUNT       (\"memberCount()\"),\n    PURE_RELAYER            (\"relayer()\");\n\n    private static Map<ByteArrayWrapper, BridgeFuncSig> enumSet = new HashMap<>();\n\n    static {\n        for (BridgeFuncSig v : BridgeFuncSig.values()) {\n            enumSet.put(v.sigWrapper, v);\n        }\n    }\n\n    private ByteArrayWrapper sigWrapper;\n    private String signature;\n\n    BridgeFuncSig(@Nonnull final String signature) {\n        this.signature = signature;\n        this.sigWrapper = new ByteArrayWrapper(toSignature(signature));\n    }\n\n    /**\n     * Maintains a 1-1 mapping between the function signature and the enum representation.\n     *\n     * @param arr 4-byte array input\n     * @return {@code enum} representing the function signature to be switched upon, if\n     * the input is considered malformed, or the signature is missing this function will\n     * return {@code null}\n     */\n    public static BridgeFuncSig getSignatureEnum(@Nonnull final byte[] arr) {\n        if (arr.length != 4)\n            return null;\n\n        return enumSet.get(new ByteArrayWrapper(arr));\n    }\n\n    public byte[] getBytes() {\n        return this.sigWrapper.toBytes();\n    }\n\n    public String getSignature() {\n        return this.signature;\n    }\n}",
      "language": "javascript",
      "name": " \tBridgeFuncSig.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport javax.annotation.Nonnull;\nimport org.aion.base.db.IRepositoryCache;\nimport org.aion.base.type.Address;\nimport org.aion.base.util.ByteUtil;\nimport org.aion.base.vm.IDataWord;\nimport org.aion.crypto.HashUtil;\nimport org.aion.mcf.core.AccountState;\nimport org.aion.mcf.db.IBlockStoreBase;\nimport org.aion.mcf.vm.types.DataWord;\nimport org.aion.mcf.vm.types.DoubleDataWord;\nimport org.aion.precompiled.PrecompiledUtilities;\n\n/**\n * Storage layout mapping as the following:\n *\n * ------------------------------------------------------------\n * owner            DWORD   0x0     current owner of the contract\n * newOwner         DWORD   0x1     proposed new owner of the contract\n *\n * memberCount      WORD    0x2     the total amount of members\n * minThresh        WORD    0x3     the minimum amount of votes required\n * ringLocked       WORD    0x4     if the ring is locked or not\n *\n * There are two mapping fields:\n * memberMap        map[WORD] => boolean    {@code TRUE} if member is active\n * bundleMap        map[WORD] => boolean    {@code TRUE} if bundle has been processed\n *\n * Maps are prepended with respective offsets, their keys are derived\n * as the following:\n *\n * {@code h256(concat(MAP_OFFSET, key))}\n *\n * Handles all loading/unloading, disguises itself like a simple POJO\n * from the outside.\n *\n * Impl Detail Notes (Contracts):\n *\n * [C1] The storage does not distinguish between empty byte array (16 bytes 0) and nulls.\n * Any time it detects that the response is a 16-byte 0, a null is returned instead.\n *\n */\npublic class BridgeStorageConnector {\n\n    private enum S_OFFSET {\n        OWNER(new DataWord(0x0)),\n        NEW_OWNER(new DataWord(0x1)),\n        MEMBER_COUNT(new DataWord(0x2)),\n        MIN_THRESH(new DataWord(0x3)),\n        RING_LOCKED(new DataWord(0x4)),\n        RELAYER(new DataWord(0x5)),\n        INITIALIZED(new DataWord(0x42));\n\n        private final DataWord offset;\n\n        S_OFFSET(DataWord offset) {\n            this.offset = offset;\n        }\n    }\n\n    private enum M_ID {\n        BUNDLE_MAP((byte) 0x1),\n        ACTIVE_MAP((byte) 0x2);\n\n        private final byte[] id;\n\n        M_ID(byte id) {\n            this.id = new byte[] {id};\n        }\n    }\n\n    private final IRepositoryCache<AccountState, IDataWord, IBlockStoreBase<?, ?>> track;\n    private final Address contractAddress;\n\n    public BridgeStorageConnector(\n            @Nonnull final IRepositoryCache<AccountState, IDataWord, IBlockStoreBase<?, ?>> track,\n            @Nonnull final Address contractAddress) {\n        this.track = track;\n        this.contractAddress = contractAddress;\n    }\n\n    public void setInitialized(final boolean initialized) {\n        DataWord init = initialized ? new DataWord(1) : new DataWord(0);\n        this.setWORD(S_OFFSET.INITIALIZED.offset, init);\n    }\n\n    public boolean getInitialized() {\n        byte[] word = this.getWORD(S_OFFSET.INITIALIZED.offset);\n        return word != null && (word[15] & 0x1) == 1;\n    }\n\n    public void setOwner(@Nonnull final byte[] address) {\n        assert address.length == 32 : \"address length must be 32 bytes\";\n        this.setDWORD(S_OFFSET.OWNER.offset, address);\n    }\n\n    public byte[] getOwner() {\n        return this.getDWORD(S_OFFSET.OWNER.offset);\n    }\n\n    public void setNewOwner(@Nonnull final byte[] address) {\n        assert address.length == 32 : \"address length must be 32 bytes\";\n        this.setDWORD(S_OFFSET.NEW_OWNER.offset, address);\n    }\n\n\n    public byte[] getNewOwner() {\n        return this.getDWORD(S_OFFSET.NEW_OWNER.offset);\n    }\n\n    public void setRelayer(@Nonnull final byte[] address) {\n        assert address.length == 32 : \"address length must be 32 bytes\";\n        this.setDWORD(S_OFFSET.RELAYER.offset, address);\n    }\n\n    public byte[] getRelayer() {\n        return this.getDWORD(S_OFFSET.RELAYER.offset);\n    }\n\n    public void setMemberCount(int amount) {\n        assert amount >= 0 : \"amount must be positive\";\n        this.setWORD(S_OFFSET.MEMBER_COUNT.offset, new DataWord(amount));\n    }\n\n    public int getMemberCount() {\n        byte[] countWord = this.getWORD(S_OFFSET.MEMBER_COUNT.offset);\n        if (countWord == null)\n            return 0;\n        return new BigInteger(1, countWord).intValueExact();\n    }\n\n    public void setMinThresh(int amount) {\n        assert amount >= 0 : \"amount must be positive\";\n        this.setWORD(S_OFFSET.MIN_THRESH.offset, new DataWord(amount));\n    }\n\n    public int getMinThresh() {\n        // C1 covered by getWORD\n        byte[] threshWord = this.getWORD(S_OFFSET.MIN_THRESH.offset);\n        if (threshWord == null)\n            return 0;\n        return new BigInteger(1, threshWord).intValueExact();\n    }\n\n    // TODO: this can be optimized\n    public void setRingLocked(boolean value) {\n        DataWord lockedDw = value ? new DataWord(1) : new DataWord(0);\n        this.setWORD(S_OFFSET.RING_LOCKED.offset, lockedDw);\n    }\n\n    public boolean getRingLocked() {\n        // C1 covered by getWORD\n        byte[] lockedWord = this.getWORD(S_OFFSET.RING_LOCKED.offset);\n        if (lockedWord == null)\n            return false;\n        // this may be redundant\n        return (lockedWord[15] & 0x01) == 1;\n    }\n\n    // TODO: this can be optimized\n    public void setActiveMember(@Nonnull final byte[] key,\n                                final boolean value) {\n        assert key.length == 32;\n        byte[] h = ByteUtil.chop(\n                HashUtil.h256(ByteUtil.merge(M_ID.ACTIVE_MAP.id, key)));\n        DataWord hWord = new DataWord(h);\n        DataWord b = value ? new DataWord(1) : new DataWord(0);\n        this.setWORD(hWord, b);\n    }\n\n    public boolean getActiveMember(@Nonnull final byte[] key) {\n        assert key.length == 32;\n        byte[] h = ByteUtil.chop(HashUtil.h256(ByteUtil.merge(M_ID.ACTIVE_MAP.id, key)));\n        DataWord hWord = new DataWord(h);\n\n        // C1 covered by getWORD\n        byte[] activeMemberWord = this.getWORD(hWord);\n        return activeMemberWord != null && (activeMemberWord[15] & 0x01) == 1;\n    }\n\n    /**\n     * @implNote ATB-4 changes, we have a new requirement in the contract\n     * to store the value (transactionHash) of when the bundle was set\n     * into the block.\n     *\n     * Therefore, where previously we were checking whether the bundle\n     * was valid based on a {@code true/false} assumption, we now check\n     * whether the bundle is valid based on whether the returned address\n     * equates to a zero word.\n     *\n     * Documentation on the change can be found as part of v0.0.4\n     * changes.\n     */\n    public void setBundle(@Nonnull final byte[] key,\n                          @Nonnull final byte[] value) {\n        assert key.length == 32;\n        assert value.length == 32;\n\n        byte[] h = ByteUtil.chop(HashUtil.h256(ByteUtil.merge(M_ID.BUNDLE_MAP.id, key)));\n        DataWord hWord = new DataWord(h);\n        this.setDWORD(hWord, value);\n    }\n\n    /**\n     * @implNote changed as part of ATB-4, see {@link #setBundle(byte[], byte[])}\n     * above for more information.\n     *\n     * @implNote note here that we return an EMPTY_WORD, this is checked in\n     * the controller layer and equates to a false.\n     *\n     * @param key bundleHash\n     * @return {@code EMPTY_WORD (32)} if no blockHash is found, {@code transactionHash}\n     *         of the input transaction otherwise.\n     */\n    public byte[] getBundle(@Nonnull final byte[] key) {\n        assert key.length == 32;\n        byte[] h = ByteUtil.chop(HashUtil.h256(ByteUtil.merge(M_ID.BUNDLE_MAP.id, key)));\n        DataWord hWord = new DataWord(h);\n        byte[] bundleDoubleWord = this.getDWORD(hWord);\n        if (bundleDoubleWord == null)\n            return ByteUtil.EMPTY_WORD;\n\n        // paranoid, this should typically never happen\n        if (bundleDoubleWord.length < 32)\n            bundleDoubleWord = PrecompiledUtilities.pad(bundleDoubleWord, 32);\n\n        return bundleDoubleWord;\n    }\n\n    // DWORD helpers\n\n    private byte[] getWORD(@Nonnull final DataWord key) {\n        IDataWord word = this.track.getStorageValue(contractAddress, key);\n        // C1\n        if (word == null || Arrays.equals(word.getData(), ByteUtil.EMPTY_HALFWORD))\n            return null;\n        return word.getData();\n    }\n\n    private void setWORD(@Nonnull final DataWord key,\n                         @Nonnull final DataWord word) {\n        this.track.addStorageRow(contractAddress, key, word);\n    }\n\n    private void setDWORD(@Nonnull final DataWord key,\n                          @Nonnull final byte[] dword) {\n        assert dword.length > 16;\n        this.track.addStorageRow(contractAddress, key, new DoubleDataWord(dword));\n    }\n\n    private byte[] getDWORD(@Nonnull final DataWord key) {\n        IDataWord word = this.track.getStorageValue(contractAddress, key);\n        if (word == null)\n            return null;\n\n        if (word.isZero())\n            return null;\n        return word.getData();\n    }\n}",
      "language": "javascript",
      "name": "BridgeStorageConnector.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport java.util.Arrays;\nimport org.aion.precompiled.PrecompiledUtilities;\n\nimport javax.annotation.Nonnull;\nimport java.math.BigInteger;\n\npublic class BridgeTransfer {\n\n    /**\n     * Consists of the sourceTransactionHash (32 bytes), the recipient address (32 bytes)\n     * and the value (padded to 16 bytes).\n     */\n    static final int TRANSFER_SIZE = 32 + 32 + 16;\n\n    private final BigInteger transferValue;\n    private final byte[] recipient;\n    private final byte[] sourceTransactionHash;\n\n    private BridgeTransfer(@Nonnull final BigInteger transferValue,\n                   @Nonnull final byte[] recipient,\n                   @Nonnull final byte[] sourceTransactionHash) {\n        this.transferValue = transferValue;\n        this.recipient = recipient.length == 32 ? recipient : Arrays.copyOf(recipient, 32);\n        this.sourceTransactionHash =\n            sourceTransactionHash.length == 32\n                ? sourceTransactionHash\n                : Arrays.copyOf(sourceTransactionHash, 32);\n    }\n    \n    static BridgeTransfer getInstance(@Nonnull final BigInteger transferValue,\n                                      @Nonnull final byte[] recipient,\n                                      @Nonnull final byte[] sourceTransactionHash) {\n        if (transferValue.toByteArray().length > 16)\n            return null;\n        return new BridgeTransfer(transferValue, recipient, sourceTransactionHash);\n    }\n\n    byte[] getRecipient() {\n        return this.recipient;\n    }\n\n    byte[] getSourceTransactionHash() {\n        return this.sourceTransactionHash;\n    }\n\n    byte[] getTransferValueByteArray() {\n        return PrecompiledUtilities.pad(transferValue.toByteArray(), 16);\n    }\n\n    BigInteger getTransferValue() {\n        return this.transferValue;\n    }\n}",
      "language": "javascript",
      "name": "BridgeTransfer.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport org.aion.base.util.ByteUtil;\nimport org.aion.crypto.HashUtil;\nimport org.aion.precompiled.PrecompiledUtilities;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\n\npublic class BridgeUtilities {\n\n    static byte[] toSignature(@Nonnull final String funcSignature) {\n        byte[] sigChopped = new byte[4];\n        byte[] full = HashUtil.keccak256(funcSignature.getBytes());\n        System.arraycopy(full, 0, sigChopped, 0, 4);\n        return sigChopped;\n    }\n\n    static byte[] toEventSignature(@Nonnull final String eventSignature) {\n        return HashUtil.keccak256(eventSignature.getBytes());\n    }\n\n    static byte[] getSignature(@Nonnull final byte[] input) {\n        if (input.length < 4)\n            return null;\n\n        byte[] sig = new byte[4];\n        System.arraycopy(input, 0, sig, 0, 4);\n        return sig;\n    }\n\n    static byte[] orDefaultWord(@Nullable final byte[] input) {\n        return input == null ? ByteUtil.EMPTY_HALFWORD : input;\n    }\n\n    static byte[] orDefaultDword(@Nullable final byte[] input) {\n        return input == null ? ByteUtil.EMPTY_WORD : input;\n    }\n\n    private static final byte[] TRUE = ByteUtil.hexStringToBytes(\"00000000000000000000000000000001\");\n    static byte[] booleanToResultBytes(final boolean input) {\n        return input ? TRUE : ByteUtil.EMPTY_HALFWORD;\n    }\n\n    static byte[] intToResultBytes(final int input) {\n        return PrecompiledUtilities.pad(BigInteger.valueOf(input).toByteArray(), 16);\n    }\n\n    static byte[] computeBundleHash(byte[] sourceBlockHash, BridgeTransfer[] bundles) {\n        int size = sourceBlockHash.length + bundles.length * BridgeTransfer.TRANSFER_SIZE;\n\n        ByteBuffer buf = ByteBuffer.allocate(size);\n        buf.put(sourceBlockHash);\n\n        for (BridgeTransfer b : bundles) {\n            buf.put(b.getSourceTransactionHash());\n            buf.put(b.getRecipient());\n            buf.put(b.getTransferValueByteArray());\n        }\n\n        return HashUtil.h256(buf.array());\n    }\n}",
      "language": "javascript",
      "name": "BridgeUtilities.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport javax.annotation.Nonnull;\n\nclass BundleRequestCall {\n    public final byte[] blockHash;\n    public final BridgeTransfer[] bundles;\n    public final byte[][] signatures;\n\n    public BundleRequestCall(@Nonnull final byte[] blockHash,\n                             @Nonnull final BridgeTransfer[] bundles,\n                             @Nonnull final byte[][] signatures) {\n        this.blockHash = blockHash;\n        this.bundles = bundles;\n        this.signatures = signatures;\n    }\n}",
      "language": "javascript",
      "name": "BundleRequestCall.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\n// utility helpers\npublic enum ErrCode {\n    NO_ERROR(0x0),\n    NOT_OWNER(0x1),\n    NOT_NEW_OWNER(0x2),\n    RING_LOCKED(0x3),\n    RING_NOT_LOCKED(0x4),\n    RING_MEMBER_EXISTS(0x5),\n    RING_MEMBER_NOT_EXISTS(0x6),\n    NOT_RING_MEMBER(0x7),\n    NOT_ENOUGH_SIGNATURES(0x8),\n    INVALID_SIGNATURE_BOUNDS(0x9),\n    INVALID_TRANSFER(0xA),\n    NOT_RELAYER(0xB),\n    PROCESSED(0xC),\n    UNCAUGHT_ERROR(0x1337);\n\n    private final int errCode;\n\n    ErrCode(int i) {\n        this.errCode = i;\n    }\n}",
      "language": "javascript",
      "name": "ErrCode.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport org.aion.base.db.IRepositoryCache;\nimport org.aion.base.type.Address;\nimport org.aion.base.util.ByteUtil;\nimport org.aion.base.vm.IDataWord;\nimport org.aion.mcf.core.AccountState;\nimport org.aion.mcf.db.IBlockStoreBase;\nimport org.aion.mcf.vm.types.DataWord;\nimport org.aion.precompiled.type.StatefulPrecompiledContract;\nimport org.aion.vm.ExecutionContext;\nimport org.aion.vm.ExecutionResult;\nimport org.aion.zero.types.AionInternalTx;\n\nimport javax.annotation.Nonnull;\nimport java.math.BigInteger;\n\nimport static org.aion.precompiled.contracts.ATB.BridgeDeserializer.*;\nimport static org.aion.precompiled.contracts.ATB.BridgeUtilities.*;\n\npublic class TokenBridgeContract extends StatefulPrecompiledContract implements Transferable {\n\n    private static final long ENERGY_CONSUME = 21000L;\n\n    // queries\n\n    private final ExecutionContext context;\n    private final IRepositoryCache<AccountState, IDataWord, IBlockStoreBase<?, ?>> track;\n\n    private final BridgeStorageConnector connector;\n    private final BridgeController controller;\n    private final Address contractAddress;\n\n    // some useful defaults\n    // TODO: add passing returns (need more though on gas consumption)\n\n    public TokenBridgeContract(@Nonnull final ExecutionContext context,\n                               @Nonnull final IRepositoryCache<AccountState, IDataWord, IBlockStoreBase<?, ?>> track,\n                               @Nonnull final Address ownerAddress,\n                               @Nonnull final Address contractAddress) {\n        super(track);\n        this.context = context;\n        this.track = track;\n        this.connector = new BridgeStorageConnector(this.track, contractAddress);\n        this.controller = new BridgeController(this.connector, this.context.helper(), contractAddress, ownerAddress);\n        this.controller.setTransferable(this);\n\n        this.contractAddress = contractAddress;\n    }\n\n    public BridgeController getController() {\n        return this.controller;\n    }\n\n    public BridgeStorageConnector getConnector() {\n        return this.connector;\n    }\n\n    public boolean isInitialized() {\n        return this.connector.getInitialized();\n    }\n\n    @Override\n    public ExecutionResult execute(@Nonnull final byte[] input, final long nrgLimit) {\n        if (nrgLimit < ENERGY_CONSUME)\n            return THROW;\n\n        // as a preset, try to initialize before execution\n        // this should be placed before the 0 into return, rationale is that we want to\n        // activate the contract the first time the owner interacts with it. Which is\n        // exactly what sending the contract currency entails\n        this.controller.initialize();\n\n        // acts as a pseudo fallback function\n        if (input.length == 0) {\n            return success();\n        }\n\n        byte[] signature = getSignature(input);\n        if (signature == null)\n            return THROW;\n\n        BridgeFuncSig sig = BridgeFuncSig.getSignatureEnum(signature);\n        if (sig == null)\n            return THROW;\n\n        switch(sig) {\n            case SIG_CHANGE_OWNER: {\n                if (!isFromAddress(this.connector.getOwner()))\n                    return fail();\n\n                byte[] address = parseAddressFromCall(input);\n                if (address == null)\n                    return fail();\n\n                ErrCode code = this.controller.setNewOwner(this.context.sender().toBytes(), address);\n\n                if (code != ErrCode.NO_ERROR)\n                    return fail();\n                return success();\n            }\n            case SIG_ACCEPT_OWNERSHIP: {\n                ErrCode code = this.controller.acceptOwnership(this.context.sender().toBytes());\n                if (code !=  ErrCode.NO_ERROR)\n                    return fail();\n                return success();\n            }\n            case SIG_RING_INITIALIZE: {\n                if (!isFromAddress(this.connector.getOwner()))\n                    return fail();\n\n                byte[][] addressList = parseAddressList(input);\n\n                if (addressList == null)\n                    return fail();\n\n                ErrCode code = this.controller.ringInitialize(this.context.sender().toBytes(), addressList);\n                if (code != ErrCode.NO_ERROR)\n                    return fail();\n                return success();\n            }\n            case SIG_RING_ADD_MEMBER: {\n                if (!isFromAddress(this.connector.getOwner()))\n                    return fail();\n\n                byte[] address = parseAddressFromCall(input);\n                if (address == null)\n                    return fail();\n\n                ErrCode code = this.controller.ringAddMember(this.context.sender().toBytes(), address);\n                if (code != ErrCode.NO_ERROR)\n                    return fail();\n                return success();\n            }\n            case SIG_RING_REMOVE_MEMBER: {\n                if (!isFromAddress(this.connector.getOwner()))\n                    return fail();\n\n                byte[] address = parseAddressFromCall(input);\n\n                if (address == null)\n                    return fail();\n\n                ErrCode code = this.controller.ringRemoveMember(this.context.sender().toBytes(), address);\n                if (code != ErrCode.NO_ERROR)\n                    return fail();\n                return success();\n            }\n            case SIG_SET_RELAYER: {\n                if (!isFromAddress(this.connector.getOwner()))\n                    return fail();\n\n                byte[] address = parseAddressFromCall(input);\n                if (address == null)\n                    return fail();\n                ErrCode code = this.controller.setRelayer(this.context.sender().toBytes(), address);\n\n                if (code != ErrCode.NO_ERROR)\n                    return fail();\n                return success();\n            }\n            case SIG_SUBMIT_BUNDLE: {\n                if (!isFromAddress(this.connector.getRelayer()))\n                    return fail();\n\n                BundleRequestCall bundleRequests = parseBundleRequest(input);\n\n                if (bundleRequests == null)\n                    return fail();\n\n                // ATB-4, as part of the changes we now\n                // pass in the transactionHash of the call\n                // into the contract, this will be logged so that\n                // we can refer to it at a later time.\n                BridgeController.ProcessedResults results = this.controller.processBundles(\n                        this.context.sender().toBytes(),\n                        this.context.transactionHash(),\n                        bundleRequests.blockHash,\n                        bundleRequests.bundles,\n                        bundleRequests.signatures);\n\n                if (results.controllerResult != ErrCode.NO_ERROR)\n                    return fail();\n                return success();\n            }\n            case PURE_OWNER:\n                return success(orDefaultDword(this.connector.getOwner()));\n            case PURE_NEW_OWNER:\n                return success(orDefaultDword(this.connector.getNewOwner()));\n            case PURE_RING_LOCKED:\n                return success(booleanToResultBytes(this.connector.getRingLocked()));\n            case PURE_MIN_THRESH:\n                return success(intToResultBytes(this.connector.getMinThresh()));\n            case PURE_MEMBER_COUNT:\n                return success(intToResultBytes(this.connector.getMemberCount()));\n            case PURE_RING_MAP: {\n                byte[] address2 = parseAddressFromCall(input);\n                if (address2 == null)\n                    return fail();\n                return success(booleanToResultBytes(this.connector.getActiveMember(address2)));\n            }\n            case PURE_ACTION_MAP:\n                byte[] bundleHash = parseDwordFromCall(input);\n                if (bundleHash == null)\n                    return fail();\n                return success(orDefaultDword(this.connector.getBundle(bundleHash)));\n            case PURE_RELAYER:\n                // ATB-5 Add in relayer getter\n                return success(orDefaultDword(this.connector.getRelayer()));\n            default:\n                return fail();\n        }\n        // throw new RuntimeException(\"should never reach here\");\n    }\n\n    private static final ExecutionResult THROW =\n            new ExecutionResult(ExecutionResult.ResultCode.FAILURE, 0);\n    private ExecutionResult fail() {\n        this.context.helper().rejectInternalTransactions();\n        return THROW;\n    }\n\n    private ExecutionResult success() {\n        long energyRemaining = this.context.nrgLimit() - ENERGY_CONSUME;\n        return new ExecutionResult(ExecutionResult.ResultCode.SUCCESS, energyRemaining);\n    }\n\n    private ExecutionResult success(@Nonnull final byte[] response) {\n        // should always be positive\n        long energyRemaining = this.context.nrgLimit() - ENERGY_CONSUME;\n        assert energyRemaining >= 0;\n        return new ExecutionResult(ExecutionResult.ResultCode.SUCCESS, energyRemaining, response);\n    }\n\n\n    private boolean isFromAddress(byte[] address) {\n        if (address == null)\n            return false;\n        return this.context.sender().equals(Address.wrap(address));\n    }\n\n    /**\n     * Performs a transfer of value from one account to another, using a method that\n     * mimics to the best of it's ability the {@code CALL} opcode. There are some\n     * assumptions that become important for any caller to know:\n     *\n     * @implNote this method will check that the recipient account has no code. This\n     * means that we <b>cannot</b> do a transfer to any contract account.\n     *\n     * @implNote assumes that the {@code fromValue} derived from the track will never\n     * be null.\n     *\n     * @param to recipient address\n     * @param value to be sent (in base units)\n     * @return {@code true} if value was performed, {@code false} otherwise\n     */\n    public ExecutionResult transfer(@Nonnull final byte[] to,\n                                    @Nonnull final BigInteger value) {\n        // some initial checks, treat as failure\n        if (this.track.getBalance(this.contractAddress).compareTo(value) < 0)\n            return new ExecutionResult(ExecutionResult.ResultCode.FAILURE, 0);\n\n        // assemble an internal transaction\n        Address from = this.contractAddress;\n        Address recipient = new Address(to);\n        BigInteger nonce = this.track.getNonce(from);\n        DataWord valueToSend = new DataWord(value);\n        byte[] dataToSend = new byte[0];\n        AionInternalTx tx = newInternalTx(from, recipient, nonce, valueToSend, dataToSend, \"call\");\n\n        // add transaction to result\n        this.context.helper().addInternalTransaction(tx);\n\n        // increase the nonce and do the transfer without executing code\n        this.track.incrementNonce(from);\n        this.track.addBalance(from, value.negate());\n        this.track.addBalance(recipient, value);\n\n        // construct result\n        return new ExecutionResult(ExecutionResult.ResultCode.SUCCESS, 0);\n    }\n\n    /**\n     * Creates a new internal transaction.\n     *\n     * NOTE: copied from {@link org.aion.fastvm.Callback}\n     */\n    private AionInternalTx newInternalTx(Address from, Address to, BigInteger nonce, DataWord value, byte[] data,\n                                                String note) {\n        byte[] parentHash = context.transactionHash();\n        int depth = context.depth();\n        int index = context.helper().getInternalTransactions().size();\n\n        return new AionInternalTx(parentHash, depth, index, new DataWord(nonce).getData(), from, to, value.getData(), data, note);\n    }\n",
      "language": "javascript",
      "name": "TokenBridgeContract.java"
    },
    {
      "code": "package org.aion.precompiled.contracts.ATB;\n\nimport org.aion.vm.ExecutionResult;\n\nimport javax.annotation.Nonnull;\nimport java.math.BigInteger;\n\npublic interface Transferable {\n    /**\n     *\n     * Performs a transfer of value from one account to another, using a method that\n     * mimicks to the best of it's ability the {@code CALL} opcode. There are some\n     * assumptions that become important for any caller to know:\n     *\n     * @implNote this method will check that the recipient account has no code. This\n     * means that we <b>cannot</b> do a transfer to any contract account.\n     *\n     * @implNote assumes that the {@code fromValue} derived from the track will never\n     * be null.\n     *\n     * @param to recipient address\n     * @param value to be sent (in base units)\n     * @return {@code true} if value was performed, {@code false} otherwise\n     */\n    ExecutionResult transfer(@Nonnull final byte[] to, @Nonnull final BigInteger value);\n}",
      "language": "javascript",
      "name": "Transferable.java"
    }
  ]
}
[/block]