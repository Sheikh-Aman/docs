---
title: "Common Use Case Smart Contract Examples"
excerpt: ""
---
[block:api-header]
{
  "title": "Overview"
}
[/block]
Looking for a specific use case example? Check out these tutorials down below!

If you want to use a popular smart contract and port it over for it to be compatible to be with Aion - check out our migration guide for [Ethereum to Aion smart contract migration guide!](doc:smart-contracts-aion-vs-ethereum) 
[block:api-header]
{
  "title": "1. Escrow"
}
[/block]
## 1.1 Description
[block:callout]
{
  "type": "info",
  "title": "What is an Escrow?",
  "body": "Escrow is a legal concept in which a financial instrument or an asset is held by a third party on behalf of two other parties that are in the process of completing a transaction. The funds or assets are held by the escrow agent until it receives the appropriate instructions or until predetermined contractual obligations have been fulfilled. \n\nEscrow comes into play when two parties are in the process of completing a transaction and there is uncertainty over whether one party or another will be able to fulfill their obligations."
}
[/block]
Escrows are a great example use case for smart contracts, as it takes the trust from opposing parties/users and places it in an executable smart contract. When certain conditions are met, such as the maximum amount of people have placed a bet - the smart contract will fire the method call automatically and pick a winner and distribute prizes.

If you'd like to re-create our demo dApp built on top of Aion - check out this guide: [ðŸŽ“ Build a Decentralized App on Aion](doc:create-dapp-on-aion-tutorial) 

## 1.2 Betting Smart Contract
Smart Contract Logic: 
* `maxNumberOfBets` = 7 accounts choose an animal to win the round
* `checkPlayerExists()` - Each account can place one bet per round
* `minimumBet` / `maximumBet` - Bets must be within 1 and 100 AION
* `onEndGame` *(last bet has been placed)*
  * `generateNumberWinner()` - contract to randomly generate a winning number
  * `distributePrizes()` - tally winners and distribute winning payouts

[See full contract here](https://github.com/aion-kimcodeashian/aion-roulette/blob/master/contracts/Casino.sol)
[block:code]
{
  "codes": [
    {
      "code": "pragma solidity ^0.4.15;\n\n/// @title Contract to bet AION for a number and win randomly when the number of bets is met.\ncontract Casino {\n  using SafeMath for uint;\n  address owner;\n  \n  uint public minimumBet = 1; // The minimum bet a user has to make to participate in the game\n  uint public maximumBet = 100; // The maximum bet a user has to make to participate in the game\n  uint public numberOfBets; // The total number of bets the users have made\n  uint public maxAmountOfBets = 7; // The maximum amount of bets can be made for each game\n  uint public totalBet; // The total amount of AION bet for this current game\n  uint public totalPaid; // The total amount of AION paid out (contract paid out)\n  uint public lastLuckyAnimal; // The number / animal that won the last game\n  uint public numberRound; // The current round number\n  address[] public players; // Array of players in each round\n\n  struct Player {\n    uint amountBet;\n    uint numberSelected;\n  }\n  \n  mapping(address => Player) public playerInfo; // The address of the player and => the user info\n\n  event AnimalChosen(uint value);\n  event WinnerTransfer(address to, uint value);\n\n  \n  modifier onEndGame(){ // Modifier to only allow the execution of functions when the bets are completed\n    if(numberOfBets >= maxAmountOfBets) _;\n  }\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function Casino(){\n    owner = msg.sender;\n  }\n\n  function() public payable {} // Make sure contract has balance > maximumBet so distributePrizes will be able to execute without failure\n\n  \n  function refund() public onlyOwner { // refund all tokens back to owner\n    uint totalBalance = this.balance;\n    owner.transfer(totalBalance);\n  }\n\n  function kill() public { // kill contract\n    if(msg.sender == owner) selfdestruct(owner);\n   }\n  \n  /// @notice Check if a player exists in the current game\n  /// @param player The address of the player to check\n  /// @return bool Returns true is it exists or false if it doesn't\n  function checkPlayerExists(address player) public constant returns(bool){\n    for(uint i = 0; i < players.length; i++){\n      if(players[i] == player) return true;\n    }\n    return false;\n }\n\n  /// @notice To bet for a number by sending AION\n  /// @param numberSelected The number that the player wants to bet for. Must be between 1 and 10 both inclusive\n  function bet(uint numberSelected) payable {\n \n    require(numberOfBets <= maxAmountOfBets); // Check that the max amount of bets hasn't been met yet\n    require(numberSelected >= 1 && numberSelected <= 10); // Check that the number to bet is within the range\n    require(checkPlayerExists(msg.sender) == false); // Check that the player doesn't exists\n    require(msg.value >= minimumBet); // Check that the amount paid is bigger or equal the minimum bet\n\n    playerInfo[msg.sender].amountBet = msg.value;\n    playerInfo[msg.sender].numberSelected = numberSelected;\n    numberOfBets++;\n    players.push(msg.sender);\n    totalBet += msg.value;\n\n    if(numberOfBets >= maxAmountOfBets) generateNumberWinner();\n  }\n\n  /// @notice Generates a random number between 1 and 10 both inclusive.\n  /// Can only be executed when the game ends.\n  function generateNumberWinner() private onEndGame {\n    uint numberGenerated = block.number % 10 + 1; // This isn't secure\n    lastLuckyAnimal = numberGenerated;\n    distributePrizes();\n\n    AnimalChosen(lastLuckyAnimal);\n  }\n\n  /// @notice Sends the corresponding AION to each winner then deletes all the\n  /// players for the next game and resets the `totalBet` and `numberOfBets`\n  function distributePrizes() private onEndGame {\n    address[100] memory winners; // We have to create a temporary in memory array with fixed size\n    uint count = 0; // Winner count\n    uint winnerBetPool = 0; // Total Winner Bet Pool\n\n    // Store winners in array, and tally winner bet pool\n    for(uint i = 0; i < players.length; i++){\n      address playerAddress = players[i];\n      if(playerInfo[playerAddress].numberSelected == lastLuckyAnimal){\n        winners[count] = playerAddress;\n        winnerBetPool += playerInfo[playerAddress].amountBet;\n        count++;\n      }\n    }\n\n    if (count > 0){\n      for(uint j = 0; j < count; j++){\n        if(winners[j] != address(0)) // Check that the address in this fixed array is not empty\n        address playerAddressW = winners[j]; // Grab winning addresses\n        uint winnerAIONAmount = SafeMath.div(SafeMath.mul(totalBet, playerInfo[playerAddressW].amountBet), winnerBetPool);\n        winners[j].transfer(winnerAIONAmount); // Calculate winner proportions of the prize pool\n\n        totalPaid += winnerAIONAmount; // Add to Total Payout\n        WinnerTransfer(winners[j], winnerAIONAmount);\n      }\n      totalBet = 0; // Clear total bets, if no winner - totalBets get rolled over\n    }\n\n    players.length = 0; // Delete all the players array\n    numberOfBets = 0;   // Reset number of bets\n    numberRound++;   // Increase Round Number\n  }\n}",
      "language": "javascript",
      "name": "Betting.sol"
    }
  ]
}
[/block]
## 1.3 Marketplace Smart Contract
Below is the simplest term of a marketplace contract. 
Auction: 
* `addItem()` - Create an item for auction (only 1 item available per `itemID`)
* `buyItem()` - Buy an item (prices can be set in the front-end application and update storeTil with the balance you have. 
* `withdraw()` - Withdraw a certain amount from `storeTill`
* `refund()` - Refund money for item to purchasing customer address

If you'd like to read more about marketplace place smart contracts -  <a href="https://medium.com/the-notice-board/a-deep-dive-into-marketplace-smart-contracts-587bbc8e9776" target="_blank">read this article here</a>
[block:code]
{
  "codes": [
    {
      "code": "pragma solidity 0.4.15;\n\ncontract Auction {\n  address[100] public buyers; // array of addresses whom buys the items\n  uint private storeTill; // money in the store\n  \n  struct ItemID {\n    string item_name;\n    uint price;\n  }\n  \n  mapping(uint => ItemID) public itemInfo; // mapping of items w/ names & price\n  \n  // Add item and item info for auction \n  function addItem(uint itemID, string set_name, uint set_price) onlyOwner{\n    itemInfo[itemID].item_name = set_name; // set item name\n    itemInfo[itemID].price = set_price; // set item price\n  }\n  \n  // Buying an item\n  function buyItem(uint itemID) public payable {\n    require(itemID >= 0 && itemID <= 99); // check if itemID is valid\n    buyers[itemID] = msg.sender; // store who bought which item \n    storeTill += msg.value; // update till\n  }\n  \n  // Withdraw amt from storeTill;\n  function withdraw(int amt) private onlyOwner { // withdraw amt from till\n    owner.transfer(amt);\n  }\n  // Refund money back to customer\n\tfunction refund(uint itemID, int amt, address customer) public onlyOwner { \n    customer.transfer(amt);\n  }\n  \n  // Retrieving the buyers \n  function getBuyers() public returns (address[100] memory) {\n    return buyers;\n  }\n}",
      "language": "javascript",
      "name": "Auction.sol"
    }
  ]
}
[/block]

[block:api-header]
{
  "title": "2. Collectibles"
}
[/block]
## 2.1 Description
[block:callout]
{
  "type": "info",
  "body": "A collectible is a unique, one-of-a-kind, **non-fungible** digital asset. Like cryptocurrencies, crypto-collectibles are limited in quantity and powered by blockchain technology. But unlike cryptocurrencies, each crypto-collectable is provably unique.\n\nCollectible assets can be designed in any number of ways. Some Collectibles are computer generated works of art. Others are digital pets that you can design and customize. Each individual token has unique variations that canâ€™t be replicated.",
  "title": "What is a collectible?"
}
[/block]
Here's some guides on how to build a non-fungible token (contracts can be easily be ported over to Aion):
* <a href="https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code" target="_blank">Cryptokitties source code</a>
* <a href="https://maksimivanov.com/posts/gradient-coin-tutorial/" target="_blank">CryptoKitties Clone In 20 minutes. Non-fungible Token Tutorial</a>
* <a href="https://coiniq.com/crypto-collectibles-list/" target="_blank">Complete List of Crypto-collectibles</a>
[block:api-header]
{
  "title": "3. Custom Token"
}
[/block]
## 3.1 Description
[block:callout]
{
  "type": "info",
  "title": "What is an ATS?",
  "body": "ATS is an abbreviation for \"Aion Token Standard\" - and that standard is the protocol that allows tokens to be used natively on the Aion blockchain and along with other connected blockchain networks - given that it's setup to do so.\n\nThe purpose of its creation is to allow developers to create a fungible token that intersects functionality requirements of current DApp developers and the innovation to allow cross-chain token movements."
}
[/block]
## 3.2 Aion Token Standard Smart Contract
Below is a *sample* implementation of our <a href="https://github.com/aionnetwork/AIP/issues/4" target="_blank">Aion Token Standard</a>

A [full guide](doc:create-ats-token-aion-network) is available to walk you over on how to create, compile, and deploy a custom token on the Aion Network. 
[block:code]
{
  "codes": [
    {
      "code": "/**\n * @title ATSImpl\n * @dev see https://github.com/qoire/ATS/blob/master/contracts/ATSImpl.sol\n *\n */\n\ncontract ATSImpl is ATS, ERC20, AionInterfaceImplementer {\n    using SafeMath for uint128;\n\n    /* -- Constants -- */\n\n    address constant internal addressTypeMask = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    address constant internal zeroAddress = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /* -- ATS Contract State -- */\n\n    string internal mName;\n    string internal mSymbol;\n    uint128 internal mGranularity;\n    uint128 internal mTotalSupply;\n\n    mapping(address => uint128) internal mBalances;\n    mapping(address => mapping(address => bool)) internal mAuthorized;\n\n    // for ERC20\n    mapping(address => mapping(address => uint128)) internal mAllowed;\n    \n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    \n    function ATSImpl() {\n        \n        mName = YOUR_TOKEN_NAME;\n        mSymbol = YOUR_TOKEN_SYMBOL;\n        mTotalSupply = YOUR_TOKEN_TOTAL_SUPPLY *10**18;\n        mGranularity = YOUR_TOKEN_TOTAL_GRANULARITY;\n\t\trequire(mGranularity >= 1);\n        initialize(mTotalSupply);\n\n        // register onto CIR\n        setInterfaceDelegate(\"AIP004Token\", this);\n    }\n\n    function initialize(uint128 _totalSupply) internal {\n        mBalances[msg.sender] = _totalSupply;\n        Created(_totalSupply, msg.sender);\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public constant returns (string) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public constant returns (string) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public constant returns (uint128) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public constant returns (uint128) { return mTotalSupply; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public constant returns (uint128) { return mBalances[_tokenHolder]; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint128 _amount, bytes _userData) public {\n        doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\n\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = true;\n        AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender);\n        mAuthorized[_operator][msg.sender] = false;\n        RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {\n        return (_operator == _tokenHolder || mAuthorized[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint128 _amount, bytes _userData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _from));\n        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\n    }\n\n    function burn(uint128 _amount, bytes _holderData) public {\n        doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\n    }\n\n    function operatorBurn(address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData) public {\n        require(isOperatorFor(msg.sender, _tokenHolder));\n        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want's to be checked\n    function requireMultiple(uint128 _amount) internal constant {\n        require(_amount.div(mGranularity).mul(mGranularity) == _amount);\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    ///\n    /// Ideally, we should propose a better system that extcodesize\n    ///\n    /// *** TODO: CHANGE ME, going to require a resolution on best approach ***\n    ///\n    /// Given that we won't be able to detect code size.\n    ///\n    /// @param _addr The address to be checked\n    /// @return `true` if the contract is a regular address, `false` otherwise\n    function isRegularAddress(address _addr) internal constant returns (bool) {\n        // if (_addr == 0) { return false; }\n        // uint size;\n        // assembly { size := extcodesize(_addr) }\n        // return size == 0;\n        return true;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `erc777_tokenHolder`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\n\n        require(_to != address(0));             // forbid sending to 0x0 (=burning)\n        require(_to != address(this));          // forbid sending to the contract itself\n        require(mBalances[_from] >= _amount);   // ensure enough funds\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\n\n        Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _holderData Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(address _operator, address _tokenHolder, uint128 _amount, bytes _holderData, bytes _operatorData)\n        internal\n    {\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) >= _amount);\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\n        Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = getInterfaceDelegate(_to, \"AIP004TokenRecipient\");\n        if (recipientImplementation != 0) {\n            ATSTokenRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _userData, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to));\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _userData Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint128 _amount,\n        bytes _userData,\n        bytes _operatorData\n    )\n        internal\n    {\n        address senderImplementation = getInterfaceDelegate(_from, \"AIP004TokenSender\");\n        if (senderImplementation == 0) { return; }\n        ATSTokenSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\n    }\n\n    function liquidSupply() public constant returns (uint128) {\n        return mTotalSupply.sub(balanceOf(this));\n    }\n\n\n    /* -- Cross Chain Functionality -- */\n\n    function thaw(\n        address localRecipient,\n        uint128 amount,\n        bytes32 bridgeId,\n        bytes bridgeData,\n        bytes32 remoteSender,\n        bytes32 remoteBridgeId,\n        bytes remoteData)\n    public {\n\n    }\n\n    function freeze(\n        bytes32 remoteRecipient,\n        uint128 amount,\n        bytes32 bridgeId,\n        bytes localData)\n    public {\n\n    }\n\n    function operatorFreeze(address localSender,\n        bytes32 remoteRecipient,\n        uint128 amount,\n        bytes32 bridgeId,\n        bytes localData)\n    public {\n\n    }\n\n    /* -- ERC20 Functionality -- */\n    \n    function decimals() public constant returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transfer(address _to, uint128 _amount) public returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can't be done, it should fail.\n    function transferFrom(address _from, address _to, uint128 _amount) public returns (bool success) {\n        require(_amount <= mAllowed[_from][msg.sender]);\n\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can't be done, it should fail.\n    function approve(address _spender, uint128 _amount) public returns (bool success) {\n        mAllowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public constant returns (uint128 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n}",
      "language": "javascript",
      "name": "ATSImpl.sol"
    }
  ]
}
[/block]

[block:api-header]
{
  "title": "4. Mutlisig"
}
[/block]
## 4.1 Description
[block:callout]
{
  "type": "info",
  "title": "What is a multisig?",
  "body": "Multisig stands for multi-signature, which is a digital signature that involves two ore more addresses to sign. It's produced through the combination of different, unique signatures. The principle and architecture of multisignature design is something that existed before blockchain and cryptocurrencies. \n\nMultisig addresses may be used in different situations, but are most commonly used for addressing security concerns."
}
[/block]
**Example Of a Multisig Trustless Escrow** 
Katy wants to send some AION to John, but only if John fulfills his promise of delivering the product as per agreement. They both trust Tony to shed agreement on a dispute, but do not trust him completely with the funds. The result is, they create a 2 out of 3 multi-sig address - assigning one key per part (Katy, John, Tony). If the transaction is completed successfully, Katy and John can jointly release the funds without Tony's involvement. But, if there is a conflict between the two parties, Tony can adjudicate, and move the funds alongside Katy or John. During the transaction period, the funds are locked in and thus no one person can move the funds solely.


## 4.2 Multisig Wallet Smart Contract 
[block:code]
{
  "codes": [
    {
      "code": "//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.10;\n\ncontract multiowned {\n\n\t// TYPES\n\n    // struct for the status of a pending operation.\n    struct PendingState {\n        uint yetNeeded;\n        uint ownersDone;\n        uint index;\n    }\n\n\t// EVENTS\n\n    // this contract only has six types of events: it can accept a confirmation, in which case\n    // we record owner and operation (hash) alongside it.\n    event Confirmation(address owner, bytes32 operation);\n    event Revoke(address owner, bytes32 operation);\n    // some others are in the case of an owner changing.\n    event OwnerChanged(address oldOwner, address newOwner);\n    event OwnerAdded(address newOwner);\n    event OwnerRemoved(address oldOwner);\n    // the last one is emitted if the required signatures change\n    event RequirementChanged(uint newRequirement);\n\n\t// MODIFIERS\n\n    // simple single-sig function modifier.\n    modifier onlyowner {\n        require(isOwner(msg.sender));\n        _;\n    }\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\n    // that later attempts can be realised as the same underlying operation and\n    // thus count as confirmations.\n    modifier onlymanyowners(bytes32 _operation) {\n        require(confirmAndCheck(_operation));\n        _;\n    }\n\n\t// METHODS\n\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n    // as well as the selection of addresses capable of confirming them.\n    function multiowned(address[] _owners, uint _required) {\n        m_numOwners = _owners.length + 1;\n        m_owners[1] = msg.sender;\n        m_ownerIndex[msg.sender] = 1;\n        for (uint i = 0; i < _owners.length; ++i)\n        {\n            m_owners[2 + i] = _owners[i];\n            m_ownerIndex[_owners[i]] = 2 + i;\n        }\n        m_required = _required;\n    }\n\n    // Revokes a prior confirmation of the given operation\n    function revoke(bytes32 _operation) external {\n        uint ownerIndex = m_ownerIndex[msg.sender];\n        // make sure they're an owner\n        if (ownerIndex == 0) return;\n        uint ownerIndexBit = 2**ownerIndex;\n        var pending = m_pending[_operation];\n        if (pending.ownersDone & ownerIndexBit > 0) {\n            pending.yetNeeded++;\n            pending.ownersDone -= ownerIndexBit;\n            Revoke(msg.sender, _operation);\n        }\n    }\n\n    // Replaces an owner `_from` with another `_to`.\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n        if (isOwner(_to)) return;\n        uint ownerIndex = m_ownerIndex[_from];\n        if (ownerIndex == 0) return;\n\n        clearPending();\n        m_owners[ownerIndex] = _to;\n        m_ownerIndex[_from] = 0;\n        m_ownerIndex[_to] = ownerIndex;\n        OwnerChanged(_from, _to);\n    }\n\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n        if (isOwner(_owner)) return;\n\n        clearPending();\n        if (m_numOwners >= c_maxOwners)\n            reorganizeOwners();\n        if (m_numOwners >= c_maxOwners)\n            return;\n        m_numOwners++;\n        m_owners[m_numOwners] = _owner;\n        m_ownerIndex[_owner] = m_numOwners;\n        OwnerAdded(_owner);\n    }\n\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n        uint ownerIndex = m_ownerIndex[_owner];\n        if (ownerIndex == 0) return;\n        if (m_required > m_numOwners - 1) return;\n\n        m_owners[ownerIndex] = 0;\n        m_ownerIndex[_owner] = 0;\n        clearPending();\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n        OwnerRemoved(_owner);\n    }\n\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n        if (_newRequired > m_numOwners) return;\n        m_required = _newRequired;\n        clearPending();\n        RequirementChanged(_newRequired);\n    }\n\n    // Gets an owner by 0-indexed position (using numOwners as the count)\n    function getOwner(uint ownerIndex) external constant returns (address) {\n        return address(m_owners[ownerIndex + 1]);\n    }\n\n    function isOwner(address _addr) constant returns (bool) {\n        return m_ownerIndex[_addr] > 0;\n    }\n\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\n        var pending = m_pending[_operation];\n        uint ownerIndex = m_ownerIndex[_owner];\n\n        // make sure they're an owner\n        if (ownerIndex == 0) return false;\n\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        return !(pending.ownersDone & ownerIndexBit == 0);\n    }\n\n    // INTERNAL METHODS\n\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n        // determine what index the present sender is:\n        uint ownerIndex = m_ownerIndex[msg.sender];\n        // make sure they're an owner\n        if (ownerIndex == 0) return;\n\n        var pending = m_pending[_operation];\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\n        if (pending.yetNeeded == 0) {\n            // reset count of confirmations needed.\n            pending.yetNeeded = m_required;\n            // reset which owners have confirmed (none) - set our bitmap to 0.\n            pending.ownersDone = 0;\n            pending.index = m_pendingIndex.length++;\n            m_pendingIndex[pending.index] = _operation;\n        }\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        // make sure we (the message sender) haven't confirmed this operation previously.\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            Confirmation(msg.sender, _operation);\n            // ok - check if count is enough to go ahead.\n            if (pending.yetNeeded <= 1) {\n                // enough confirmations: reset and run interior.\n                delete m_pendingIndex[m_pending[_operation].index];\n                delete m_pending[_operation];\n                return true;\n            }\n            else\n            {\n                // not enough: record that this owner in particular confirmed.\n                pending.yetNeeded--;\n                pending.ownersDone |= ownerIndexBit;\n\n                return true; // YULONG: needs more thoughts on this\n            }\n        }\n    }\n\n    function reorganizeOwners() private {\n        uint free = 1;\n        while (free < m_numOwners)\n        {\n            while (free < m_numOwners && m_owners[free] != 0) free++;\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n            {\n                m_owners[free] = m_owners[m_numOwners];\n                m_ownerIndex[m_owners[free]] = free;\n                m_owners[m_numOwners] = 0;\n            }\n        }\n    }\n\n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            if (m_pendingIndex[i] != 0)\n                delete m_pending[m_pendingIndex[i]];\n        delete m_pendingIndex;\n    }\n\n   \t// FIELDS\n\n    // the number of owners that must confirm the same operation before it is run.\n    uint public m_required;\n    // pointer used to find a free slot in m_owners\n    uint public m_numOwners;\n\n    // list of owners\n    address[256] m_owners;\n    uint constant c_maxOwners = 250;\n    // index on the list of owners to allow reverse lookup\n    mapping(address => uint) m_ownerIndex;\n    // the ongoing operations.\n    mapping(bytes32 => PendingState) m_pending;\n    bytes32[] m_pendingIndex;\n}\n\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\n// uses is specified in the modifier.\ncontract daylimit is multiowned {\n\n\t// MODIFIERS\n\n    // simple modifier for daily limit.\n    modifier limitedDaily(uint _value) {\n        require(underLimit(_value));\n        _;\n    }\n\n\t// METHODS\n\n    // constructor - stores initial daily limit and records the present day's index.\n    function daylimit(uint _limit) {\n        m_dailyLimit = _limit;\n        m_lastDay = today();\n    }\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n        m_dailyLimit = _newLimit;\n    }\n    // resets the amount already spent today. needs many of the owners to confirm.\n    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n        m_spentToday = 0;\n    }\n\n    // INTERNAL METHODS\n\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n    // returns true. otherwise just returns false.\n    function underLimit(uint _value) internal onlyowner returns (bool) {\n        // reset the spend limit if we're on a different day to last time.\n        if (today() > m_lastDay) {\n            m_spentToday = 0;\n            m_lastDay = today();\n        }\n        // check to see if there's enough left - if so, subtract and return true.\n        // overflow protection                    // dailyLimit check\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n            m_spentToday += _value;\n            return true;\n        }\n        return false;\n    }\n    // determines today's index.\n    function today() private constant returns (uint) { return now / 1 days; }\n\n\t// FIELDS\n\n    uint public m_dailyLimit;\n    uint public m_spentToday;\n    uint public m_lastDay;\n}\n\n// interface contract for multisig proxy contracts; see below for docs.\ncontract multisig {\n\n\t// EVENTS\n\n    // logged events:\n    // Funds has arrived into the wallet (record how much).\n    event Deposit(address _from, uint value);\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n    event SingleTransact(address owner, uint value, address to, bytes data);\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\n    // Confirmation still needed for a transaction.\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n\n    // FUNCTIONS\n\n    // TODO: document\n    function changeOwner(address _from, address _to) external;\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\n    function confirm(bytes32 _h) returns (bool);\n}\n\n// usage:\n// bytes32 h = Wallet(w).from(oneOwner).execute(to, value, data);\n// Wallet(w).from(anotherOwner).confirm(h);\ncontract Wallet is multisig, multiowned, daylimit {\n\n\t// TYPES\n\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n    }\n\n    // METHODS\n\n    // constructor - just pass on the owner array to the multiowned and\n    // the limit to daylimit\n    function Wallet(address[] _owners, uint _required, uint _daylimt)\n            multiowned(_owners, _required) daylimit(_daylimt) {\n    }\n\n    // kills the contract sending everything to `_to`.\n    function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n        selfdestruct(_to);\n    }\n\n    // gets called when no other function matches\n    function() payable {\n        // just being sent some cash?\n        if (msg.value > 0)\n            Deposit(msg.sender, msg.value);\n    }\n\n    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n    // and _data arguments). They still get the option of using them if they want, anyways.\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\n        // first, take the opportunity to check that we're under the daily limit.\n        if (underLimit(_value)) {\n            SingleTransact(msg.sender, _value, _to, _data);\n            // yes - just execute the call.\n            require(_to.call.value(_value)(_data));\n            return 0;\n        }\n        // determine our operation hash.\n        _r = sha3(msg.data, block.number);\n        if (!confirm(_r) && m_txs[_r].to == 0) {\n            m_txs[_r].to = _to;\n            m_txs[_r].value = _value;\n            m_txs[_r].data = _data;\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\n        }\n    }\n\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n    // to determine the body of the transaction from the hash provided.\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\n        if (m_txs[_h].to != 0) {\n            require(m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data));\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\n            delete m_txs[_h];\n            return true;\n        }\n    }\n\n    // INTERNAL METHODS\n\n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            delete m_txs[m_pendingIndex[i]];\n        super.clearPending();\n    }\n\n\t// FIELDS\n\n    // pending transactions we have at present.\n    mapping (bytes32 => Transaction) m_txs;\n}",
      "language": "javascript",
      "name": "Wallet.sol"
    }
  ]
}
[/block]
# Need Help?

If you get stuck, try searching these docs ðŸ‘† or head over to our <a href="https://gitter.im/aionnetwork/Lobby" target="_blank">Gitter channels</a> or <a href="https://stackoverflow.com/search?q=aion" target="_blank">StackOverflow</a> for answers to some common questions.